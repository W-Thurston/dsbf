# dsbf/eda/task_result.py

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Protocol, TypedDict


class WarningDetail(TypedDict):
    description: str
    recommendation: Optional[str]


ReliabilityWarning = Dict[str, Dict[str, WarningDetail]]


@dataclass
class TaskResult:
    """
    Standardized result object returned by all EDA or diagnostic tasks.

    Attributes:
        name (str): Unique identifier for the task (e.g., 'null_summary').
        status (Literal["success", "failed", "skipped"]): Execution status of the task.
        summary (Dict[str, Any]): A short summary of key results, for use in
            reports or dashboards.
        data (Optional[Dict[str, Any]]): Core output values from the task, such as
            statistics or flags.
        plots (Optional[List[Path]]): Paths to plot image files generated by the task,
            if any.
        metadata (Dict[str, Any]): Additional metadata such as timing, config settings,
            or version info.
        recommendations (Optional[List[str]]): Optional action items or next steps
            based on findings.
        error_metadata (Optional[Dict[str, str]]): Structured diagnostic info for
            failed tasks, including error type, traceback summary, and a suggested
            action.
    """

    name: str
    status: Literal["success", "failed", "skipped"] = "success"
    summary: Dict[str, Any] = field(default_factory=dict)
    data: Optional[Dict[str, Any]] = None
    plots: Optional[List[Path]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    ml_impact_score: Optional[float] = None  # range: 0.0 to 1.0
    reliability_warnings: Optional[ReliabilityWarning] = None
    recommendations: Optional[List[str]] = None
    recommendation_tags: Optional[List[str]] = None  # e.g., ["drop", "transform"]
    error_metadata: Optional[Dict[str, str]] = None

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the TaskResult to a dictionary representation,
        making it serializable and suitable for JSON export.

        Returns:
            Dict[str, Any]: A dictionary version of the result object.
        """
        return {
            "name": self.name,
            "status": self.status,
            "summary": self.summary,
            "data": self.data,
            "plots": [str(p) for p in self.plots] if self.plots else None,
            "metadata": self.metadata,
            "ml_impact_score": self.ml_impact_score,
            "reliability_warnings": self.reliability_warnings,
            "recommendations": self.recommendations,
            "error_metadata": self.error_metadata,
        }

    def __str__(self) -> str:
        """
        String representation of the task result for quick logging.

        Returns:
            str: Short status message.
        """
        return (
            f"TaskResult(name={self.name}, status={self.status}, "
            f"summary={self.summary})"
        )


def make_failure_result(task_name: str, error: Exception) -> "TaskResult":
    """
    Create a standardized failed TaskResult for standalone task execution.

    Args:
        task_name (str): Name of the task.
        error (Exception): Exception that occurred.

    Returns:
        TaskResult: A failed result object.
    """
    return TaskResult(
        name=task_name,
        status="failed",
        summary={"message": f"Error during {task_name}: {error}"},
        error_metadata={
            "error_type": type(error).__name__,
            "trace_summary": str(error),
            "suggested_action": "Review task input or parameters",
        },
    )


def add_reliability_warning(
    result: "TaskResult",
    level: str,
    code: str,
    description: str,
    recommendation: Optional[str] = None,
) -> None:
    """
    Attach a structured warning to the TaskResult
        under the appropriate reliability tier.
    """
    from typing import cast

    if result.reliability_warnings is None:
        result.reliability_warnings = cast(ReliabilityWarning, {})

    if level not in result.reliability_warnings:
        result.reliability_warnings[level] = {}

    result.reliability_warnings[level][code] = {
        "description": description,
        "recommendation": recommendation,
    }


class LoggingTask(Protocol):
    name: str

    def _log(self, msg: str, level: str = ...) -> None: ...


def log_reliability_warnings(task: LoggingTask, result: "TaskResult") -> None:
    """
    Print reliability warnings to console if present (and verbosity = debug).
    """
    if not result.reliability_warnings:
        return

    for level, warnings in result.reliability_warnings.items():
        for code, info in warnings.items():
            task._log(
                f"[{task.name}] {level.upper()} — {code}: {info['description']}",
                level="debug",
            )
            if info.get("recommendation"):
                task._log(f"    ↪ Suggestion: {info['recommendation']}", level="debug")
